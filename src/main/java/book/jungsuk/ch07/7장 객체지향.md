# 7장 객체지향

# 상속(Inheritance)

- 기존 클래스로 새로운 클래스 작성 → `코드의 재사용`
- 두 클래스는 부모와 자식 관계
- class 클래스명 extends 부모클래스 {}
    - extends : 확장
- 자손은 `조상의 모든 멤버`를 상속 받는다. (`생성자`, `초기화 블럭` 제외)
- 자손 멤버개수는 조상 멤버개수보다 작을 수 없다.
- 부모의 변경은 자식에게 영향이 간다.
- 상속 관계 유무와 상관 없이 객체 생성 시 iv 구성은 똑같다.
    
    ⇒ 메모리에 생성되는 객체 구조
    

# 포함관계

포함 : 클래스의 멤버로 참조변수를 선언하는 것

- 클래스의 관계는 상속과 포함관계가 있다.
- 상속관계는 A는 B이다.**(is -a)**
- 포함관계는 A는 B를 가지고 있다.**(has -a)**

⇒ 절대적인 기준은 아니다. 대부분은 포함관계 (헷갈리면 포함관계를 사용하자)

<aside>
💡 프로그래밍은 설계 90 코딩 10이다 코드를 보고 그림을 그리는 실력을 키우자

</aside>

# 단일 상속

- 자바는 단일상속 불가 (C++은 다중상속 가능)
- 자바에서 다중상속과 같은 기능
    1. 인터페이스 활용
    2. 비중이 높은 클래스는 상속하고, 다른 클래스는 포함관계로 처리

# Object 클래스

- 모든 클래스의 조상 클래스 ( extends 를 하지 않아도 컴파일러가 자동으로 추가 )

# 메서드 오버라이딩

- 상속받은 조상의 메서드를 자신에 맞게 `변경`하는 것
- override : 덮어쓰다
- 오버라이딩 조건
    1. `선언부`가 조상과 **일치**
        - 선언부 : 반환타입, 메서드이름 , 매개변수 목록
    2. `접근 제어자`를 조상의 메서드보다 **좁게 변경X**
    3. `예외 선언`을 조상클래스보다 **넓게 설정 X**

### 오버로딩 vs 오버라이딩

- 사실 서로 관계가 없는 개념
- 오버로딩 : 기존에 없는 이름이 같은 새로운 메서드 정의 **(new)**
- 오버라이딩 : 상속 받은 메서드의 내용을 변경하는 것 **(change, modify)**

# 참조 변수 super

- this하고 거의 같다 ( this : 객체자신을 가리키는 참조변수, **지역변수와 인스턴스 변수를 구분**할 때 사용 )
- 객체 자신을 가리키는 변수, 인스턴스 메서드 내에만 존재
- **조상 멤버와 자신의 멤버**가 이름이 같은 경우 `구별`해야해서 사용
- 자손 클래스에 iv가 없을 경우 this.super 둘다 같다

# 조상 생성자 super()

- 조상 생성자 호출 할 때 사용(생성자와 초기화 블럭은 상속X)
- 조상의 멤버는 조상의 생성자로 호출해서 초기화
- **생성자의 첫줄엔 반드시 생성자 호출**
    - 그렇지 않으면 컴파일러가 자동으로 생성자의 첫줄에 super();를 삽입
        - 모든 클래스의 조상은 Object 때문에 오류X but 상속 받은 클래스의 부모 클래스가 기본 생성자가 없을 경우 오류가 발생한다.
            - 해결 방법 : 매개변수전달하는 조상 클래스의 생성자 호출하거나 부모 클래스의 기본 생성자를 만들어야함

# 패키지

- 서로 관련된 클래스의 묶음
- 클래스의 실제이름(full name)은 패키지를 포함

### 패키지 선언

- 패키지는 소스파일 첫문장으로 단 한번 선언
- 같은 소스 파일의 클래스들은 모두 같은 패키지
- 패키지 선언이 없으면 이름 없는 패키지에 속함

# 클래스 패스

- 클래스 파일의 위치를 알려주는 경로
- 환경 변수 class path로 관리하며, 경로간의 구분자는 ‘;’를 사용
    - os에서 관리하기 때문에 클래스 패스를 등록하면 cmd 명령어로 어디서든 해당 프로젝트 클래스들을 실행할 수 있다.

# Import문

- 클래스를 사용할 때 패키지 이름을 생략하게 해준다.
- 컴파일러에게 클래스가 속한 패키지를 알려준다.
- java.lang 은 생략 가능 → 자바 기본 패키지
- import 선언
    - 패키지명.* ⇒ 패키지 안에 모든 클래스 **(하위 패키지는 포함 X)**
    - static import
        - static 멤버를 사용 할 때 클래스 이름 생략 가능
        - 쓰는 이유 : 가독성
            
            ⇒ 꼭 필요할 때 사용하자 
            

# 제어자(modifier)

- 클래스와 클래스 멤버에 부가적인 의미 부여
- 접근 제어자 : public protected  (default) private
- 그외 : static , final , abstract , native , transient , synchronized , volatile , strictfp
- 하나의 대사엥 여러 제어자를 같이 사용 ( 접근 제어자는 only one )
- 관례상 접근 제어자 가장 왼쪽
- static 이 final보다 먼저 사용된다.

### static - 클래스의 , 공통적인

- 클래스 변수(클래스의 공통적인 속성) , 스태틱 블럭(스태틱 변수 초기화) , 스태틱 메서드(iv 사용x, 인스턴스 메서드 사용x)
- **객체 생성 없이 사용** 가능

### final - 마지막의, 변경될 수 없는

- final class : 변경될 수 없는 클래스 → 확장될 수 없는 클래스 → **다른 클래스의 조상**이 될 수 없다.
- final method : 변경될 수 없는 메서드 → **오버라이딩 불가**
- final 멤버변수 : 값을 **변경할 수 없는 상수**가 된다.

### abstract - 추상의, 미완성의

- abstract class : 추상 클래스 → `추상 메서드`를 갖고 있는 클래스 (**미완성 클래스**)
- abstract method : 추상 메서드 → 몸통이 없는 메서드 (선언부만 작성, **구현부X**)
    
    ⇒ 완성되지 않는 메서드를 갖고 있으니 당연히 미완성 클래스가 된다.
    
    미완성된 설계도로는 제품 생성 불가능 → 객체 인스턴스 생성 X
    
    ⇒ 상속 후 미완성된 설계도가 완성된 후에 객체 생성 가능
    

# 접근제어자

- private
- (default)
- protected
- public

- 클래스 ( public , (default) )
- 멤버 → 네 가지 모두 사용 가능

# 캡슐화

- 외부로부터 데이터를 보호
- 외부에 불필요한 부분을 감추기

- 접근 제어자를 통한 캡슐화
- 멤버 변수들 private 선언 (외부 접근 X)
- 접근 메서드를 통해 멤버변수 접근

# 다형성

<aside>
💡 다형성을 이해해야 추상클래스, 인터페이스를 이해할 수 있다.

</aside>

- **여러 가지 형태를 가질 수 있는 능력**
- 조상 타입 참조 변수로 자손 타입 객체를 다루는 것
- 객체와 참조변수 타입이 일치할 때와 불일치 할 때
    - 일치 할 때
        - 모든 기능 사용 가능
    - 불일치 할 때
        - 조상 참조 변수의 기능만 사용 가능
- 자손타입의 참조변수로 부모타입 객체는 가리키면 안된다.
    
    ⇒ 실제 제품 기능보다 리모컨의 버튼이 더 많기 때문이다. 
    

### 참조변수 형변환

- 사용할 수 있는 멤버의 갯수를 조절
- 조상 , 자손 관계 일 때 서로 형변환 가능
    - 실제 인스턴스가 무엇인지 중요하다.
        - 참조 변수가 실제 인스턴스의 기능을 넘어서면 안되기 때문이다.
        - `ClassCastException` 발생 ( 형변환 실행 에러 ) → 컴파일 시엔 에러를 찾지 못한다.

### instanceof 연산자

- 참조변수의 형변환 가능여부 확인에 사용 , 가능하면 true 불가능 하면 false
- 형변환 전 instanceof 로 형변환 안전한지 확인 후 형변환
- 부모의 모든 자손이 들어오니까 instanceof로 확인 해야 한다.
- 자손 instaceof 부모 → 무조건 트루이므로 주의

<aside>
💡 다형성의 장점
1. 다형적 매개변수 
2. 하나의 배열로 여러 종류 객체 다루기

</aside>

### 매개변수의 다형성

- 참조형 매개변수는 메서드 호출시, 자신과 같은 타입 또는 자손 타입의 인스턴스를 넘겨 줄 수 있다.

### 여러 종류의 객체를 배열로 다루기

- 하나의 배열로 여러 종류 객체를 다룰 수 있다.
- 조상 클래스 타입을 배열로 생성 후 배열 안을 자손 클래스로 채우기 → 여러 타입을 하나의 배열에 넣을 수 있다.

# 추상 클래스 (abstract class)

- 미완성 설계도 , 미완성 메서드를 갖고 있는 클래스
- 다른 클래스 작성에 도움을 주기 위한 것 , **인스턴스 생성 불가**
- 상속 받아서 추상메서드를 `완성`해야 인스턴스 **생성 가능**
- 미완성 클래스여도 **참조변수로 사용 가능**(다형성)
- 일반 클래스와 차이점 : `추상메서드`를 갖고 있다. ( iv, 생성자 사용 가능 )

### 추상 메서드

- 미완성 메서드 (구현부가 없는 메서드) ex) abstract 리턴타입 메서드이름();
- 추상 메서드는 언제 사용할까?
    - **꼭 필요한 기능**이지만 자손마다 `다르게 구현이 예상`될 경우
- 추상메서드는 호출이 가능하다 → 호출할때는 선언부만 필요

### 추상 클래스 작성

- 추상화 작업을 진행하는 것
    - 작성 방법(공통 부분을 나중에 뽑나, 처음부터 정하냐의 차이)
        1. 기존 클래스의 공통 부분을 뽑아서 추상 클래스로 만든다.
        2. 여러 클래스의 공통적으로 사용될 수 있는 추상 클래스를 바로 작성
- 추상화와 구체화 중 추상화가 좋은 점은?
    - 추상화된 코드는 구체화된 코드보다 유연하다. → `변경 유리`하다.

# 인터페이스

- **추상 메서드의 집합**
    - static 메서드 , 상수, 디폴트 메서드도 구성요소인데 핵심은 추상메서드의 집합
- 구현된 것이 하나도 없는 설계도 ⇒ 추상메서드의 집합이니까
- **객체의 껍데기** → 모든 멤버 `public`

### 인터페이스와 추상클래스의 차이

- 추상 클래스 : 일반클래스에 추상메서드를 갖고 있는 클래스 ( 일반 클래스와 차이점 : `추상 메서드 유무` )
- 인터페이스는 iv 가질 수 없다.
- 모든 인터페이스의 멤버는 public
    - 상수 public static final 생략 가능
    - 추상메서드 public abstract 생략 가능
    

### 인터페이스의 상속

- 인터페이스의 조상은 인터페이스만 가능 (Object 최고 조상이 아니다)
- 다중 상속이 가능 ⇒ 추상 메서드 충돌해도 문제X → 구현부가 없어서 충돌문제가 없다.

### 인터페이스 구현

- 키워드 implement(구현)
- 인터페이스에 정의된 추상 메서드를 완성
- 인터페이스의 추상메서드 중 일부만 구현 시 추상 클래스 ( 아직 미완성 메서드가 있기 때문에 )

### 인터페이스를 이용한 다형성

- 인터페이스 타입 매개변수는 인터페이스를 구현한 클래스의 객체만 가능
- 인터페이스를 메서드의 리턴 타입으로 지정 가능

### 인터페이스의 개념과 장점

- 개념 : 두 대상 (객체) 간의 **‘연결,대화,소통’**을 돕는 중간 역할
- `변경에 유리`하고 연결,대화,소통을 돕는다.
- 현실 세계 : 직접소통 대신 중간 역할 (중개인 , 기계의 껍데기 (버튼들)) ⇒ 서비스를 이용하기 쉽게 도와준다.

### 장점

1. 선언(설계)와 구현을 분리시킬 수 있게 된다.
    - 선언 → 껍데기 , 구현 → 알맹이
    - 일반 클래스 ( 선언 + 구현 )
    - 인터페이스(선언) + 구현클래스(구현)
    - 유연한 코드  → 변경에 유리
    - 예시
        
        A클래스가 B클래스(일반클래스)를 의존하고 있는 상황에서 C클래스로 변경하려고 할 때(기능 확장 및 변경)
        
        A클래스의 코드를 변경해야 한다.
        
        그러나 A클래스가 B클래스(구현클래스) 의 인터페이스를 의존하고 있는 상황에서 C클래스로 변경하려고 할 때 (기능확장 및 변경) A클래스의 코드는 변경하지 않은 채로 B클래스의 인터페이스에 또다른 구현클래스인 C클래스를 만들면 된다.
        
        ⇒ 느슨한 결합 , A는 인터페이스(껍데기)하고만 관계를 갖고 있다. (구체적으로 들어가면 외부에서 A클래스의 의존관계를 설정해줘야한다.)
        
2. 개발 시간 단축
    - 개발을 진행할 때 인터페이스를 우선적으로 만들어 놓으면 호출은 가능하기 때문에 다른 개발자가 아직 완성이 되지 않은 기능을 인터페이스를 통해서 호출해서 작업을 진행할 수 있다.
    
3. 표준화가 가능
    - JDBC → Java 표준 DB를 연동하는 인터페이스
    - Oracle, MySQL에 표준적인 기준을 보여줌으로써 JDBC 에 맞춰서 기능개발 진행
    - 사용자는 DB를 변경할 때 개발자의 코드를 변경하지 않아도 된다.
    
4. 서로 관계 없는 클래스들의 관계를 맺어줄 수 있다.
    - 상속계층도가 복잡한 경우, 새로운 관계를 맺어주기가 어렵다.
    - 인터페이스를 사용해서 상속계층도에 제약을 받지 않는 관계를 만들어 줄 수 있다.

### 디폴트 메서드와 static 메서드

- JDK 1.8부터 나타난 기능
- 인터페이스의 **새로운 메서드(추상메서드)를 추가 하기 어렵다.**
    - 구현된 클래스를 **다 변경**해야하기 때문에
    - 해결책 → 디폴트 메서드
        - 디폴트 메서드는 인스턴스 메서드이다. (몸통이 있는 메서드)
        - 기존 인터페이스 원칙에는 위반
    - 디폴트 메서드와 기존 메서드가 충돌 할때 해결책
        1. 여러 인터페이스의 디폴트 메서드 간의 충돌 → 구현 클래스에서 디폴트 메서드 오버라이딩 
        2. 디폴트 메서드와 조상 클래스 메서드 충돌 → 조상 클래스 상속 , 디폴트 무시 
        
        ⇒ **직접 오버라이딩**으로 해결해도 된다.